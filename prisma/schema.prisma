generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["orderByAggregateGroup", "selectRelationCount"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Member {
  id                    Int        @id @default(autoincrement()) @map("id")
  ethAddress            String     @db.VarChar(42) @map("eth_address")
  type                  MemberType @map("type")
  alias                 String?    @db.VarChar(42) @map("alias")
  createdEpoch          Int        @map("created_epoch")
  liquidityCapUsdc      Int?       @map("liquidity_cap_usdc")
  liquidityCapEpochUsdc Int?       @map("liquidity_cap_epoch_usdc")

  // previous ApiMember fields
  totalLiquidity     Decimal? @map("total_liquidity") @db.Decimal(20, 8)
  totalRewardsEarned Decimal? @map("total_rewards_earned") @db.Decimal(20, 8)
  netGain            Decimal? @map("net_gain") @db.Decimal(20, 8)
  netPosition        Decimal? @map("net_position") @db.Decimal(20, 8)
  claimed            Boolean  @default(false) @map("claimed")
  cap                Int?     @map("cap")
  nonce              String   @default(uuid()) @map("nonce")

  // utility fields
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // scalar relation fields
  daoId      Int @map("dao_id")
  protocolId Int @map("protocol_id")

  // relations
  dao             Dao
  protocol        Protocol
  dntTokens       DntToken[]
  usdcTokens      UsdcToken[]
  fromAllocations Allocation[] @relation("MemberToAllocation_fromMember") // maybe sentValue... receivedValue... would be better than toValue... fromValue...
  toAllocations   Allocation[] @relation("MemberToAllocation_toMember")
  fromDelegations Delegation[] @relation("MemberToDelegation_fromMember")
  toDelegations   Delegation[] @relation("MemberToDelegation_toMember")


  // contraints
  @@unique([daoId, ethAddress])
  @@unique([daoId, alias])

  // index
  @@index([ethAddress], name: "ethAddress")
  @@index([daoId], name: "member_dao_id")
  @@index([protocolId], name: "member_protocol_id")

  @@map("member")
}

model DntToken {
  id              Int                @id @default(autoincrement()) @map("id")
  transactionType DntTransactionType @map("transaction_type")
  amount          Decimal            @map("amount") @db.Decimal(20, 8)
  createdAt       DateTime           @default(now()) @map("created_at")
  updatedAt       DateTime           @updatedAt @map("updated_at")

  // scalar relation fields
  protocolId Int @map("protocol_id")
  memberId   Int @map("member_id")

  // relations
  protocol Protocol @relation(fields: [protocolId], references: [id])
  member   Member   @relation(fields: [memberId], references: [id])

  // indexes
  @@index([protocolId], name: "dnt_token_protocol_id")
  @@index([memberId], name: "dnt_token_member")

  @@map("dnt_token")
}

model Protocol {
  id                  Int      @id @default(autoincrement()) @map("id")
  epoch               Int      @map("epoch")
  dntWithdrawFee      Int      @map("dnt_withdraw_fee")
  usdcWithdrawFee     Int      @map("usdc_withdraw_fee")
  mintAmt             Int      @map("mint_amt")
  budgetAmt           Int      @map("budget_amt")
  rewardDistributions Json?    @map("dnt_reward_distributions")
  createdAt           DateTime @default(now()) @map("created_at")
  updatedAt           DateTime @updatedAt @map("updated_at")

  // scalar relation fields
  daoId Int @map("dao_id")

  // relations
  dao Dao @relation("DaoToProtocol", fields: [daoId], references: [id])

  // contraints
  @@unique([epoch, daoId])

  // indexes
  @@index([epoch])
  @@index([daoId])

  // dntRewardDistributions will be populated at the end of the epoch
  // and will contain the results of the epoch allocations.
  @@map("protocol")
}

model Delegation {
  id        Int      @id @default(autoincrement()) @map("id")
  weight    Int      @map("weight")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // scalar relation fields
  protocolId   Int @map("protocol_id")
  fromMemberId Int @map("from_member_id")
  toMemberId   Int @map("to_member_id")

  // relations
  protocol   Protocol @relation("ProtocolToDelegation", fields: [protocolId], references: [id])
  fromMember Member   @relation("MemberToDelegation_fromMember", fields: [fromMemberId], references: [id])
  toMember   Member   @relation("MemberToDelegation_toMember", fields: [fromMemberId], references: [id])

  // contraints
  @@unique([protocolId, fromMemberId, toMemberId])

  // indexes
  @@index([protocolId])
  @@index([fromMemberId])
  @@index([toMemberId])

  @@map("delegation")
}

model UsdcToken {
  id              Int                 @id @default(autoincrement()) @map("id")
  epoch           Int                 @map("epoch")
  transactionType UsdcTransactionType @map("transaction_type")
  amount          Decimal             @map("amount") @db.Decimal(20, 8)
  createdAt       DateTime            @default(now()) @map("created_at")
  updatedAt       DateTime            @updatedAt @map("updated_at")

  // scalar relation fields
  protocolId Int @map("protocol_id")
  memberId   Int @map("member_id")

  // relations
  protocol Protocol @relation("Protocol", fields: [protocolId], references: [id])
  member   Member   @relation("Member", fields: [memberId], references: [id])

  // indexes
  @@index([epoch], name: "usdc_token_epoch")
  @@index([memberId], name: "usdc_token_member_id")

  @@map("usdc_token")
}

model Allocation {
  id        Int      @id @default(autoincrement()) @map("id")
  weight    Int      @map("weight")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // scalar relation fields
  protocolId   Int @map("protocol_id")
  fromMemberId Int @map("from_member_id")
  toMemberId   Int @map("to_member_id")

  //relations
  protocol   Protocol @relation(fields: [protocolId], references: [id])
  fromMember Member   @relation("MemberToAllocation_fromMember")
  toMember   Member   @relation("MemberToAllocation_toMember")

  //contraints
  @@unique([fromMemberId, toMemberId, protocolId], name: "Allocation_fromMemberId_toMemberId_epoch_key")

  // indexes
  @@index([fromMemberId], name: "allocation_from_member_id")
  @@index([toMemberId], name: "allocation_to_member_id")
  @@index([protocolId], name: "protocol_id")

  @@map("allocation")
}

model Dao {
  id          Int    @id @default(autoincrement()) @map("id")
  name        String @map("name")
  tokenSymbol String @map("token_symbol")

  //relations
  protocols Protocol[] @relation("Protocols")
  members   Member[]   @relation("Members")
  proposals Proposal[] @relation("Proposals")

  @@map("dao")
}

// voting
model Proposal {
  // result field JSON object structure:
  // {
  //  netVotes: 500,
  //  netVotesNeeded: 0,
  //  totalAvailableVotes: 1000,
  //  inFavorOfVotes: 750,
  //  againstVotes: 250,
  //  votes: [{
  //    id: 1,
  //    ethAddress: "asdfasdfdasdf",
  //    alias: "zaz",
  //    inFavorOf: true,
  //    voteCount: 1000
  //  }]
  // }
  id         Int      @id @default(autoincrement()) @map("id")
  category   String   @map("category")
  name       String   @map("name")
  desc       String   @map("desc")
  duration   Int      @map("duration") @default(1) // the amount of epochs this vote is active for
  epoch      Int      @map("epoch")
  isApproved Boolean  @map("is_approved") @default(false)
  isActive   Boolean  @map("is_active") @default(false)
  result     Json?    @map("result")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  // scalar relation fields
  daoId           Int    @map("dao_id")
  proposerAddress String @db.VarChar(42) @map("proposer_address")

  //relations
  dao      Dao            @relation("DaoToProtocol", fields: [daoId], references: [id])
  proposer Member         @relation(fields: [proposerAddress], references: [ethAddress])
  votes    ProposalVote[]

  //indexes
  @@index([id])
  @@index([epoch])

  @@map("proposal")
}

model ProposalVote {
  id        Int      @id @default(autoincrement()) @map("id")
  inFavorOf Boolean  @map("in_favor_of")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // scalar relation fields
  proposalId   Int    @map("proposal_id")
  voterAddress String @db.VarChar(42) @map("voter_address")

  //relations
  proposal Proposal @relation(fields: [proposalId], references: [id])
  voter    Member   @relation(fields: [voterAddress], references: [ethAddress])

  // constraints
  @@unique([proposalId, voterAddress])

  //indexes
  @@index([proposalId])
  @@index([voterAddress])

  @@map("proposal_vote")
}

// enums
enum MemberType {
  ENTITY
  PERSONAL
}

enum DntTransactionType {
  CONTRIBUTOR_REWARD
  LP_REWARD
  SWAP
  STAKE
}

enum UsdcTransactionType {
  DEPOSIT
  WITHDRAW
  SWAP
}
